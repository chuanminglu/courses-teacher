# P00-组件信息自动提取提示词

> **📌 用途**: 使用 Chrome DevTools MCP + AI视觉识别，从原型/设计稿中自动提取组件开发所需的输入信息，减少手工填写工作量。

---

## 🎭 R - 角色定义

你是一位资深前端逆向工程师，拥有10年UI还原和设计分析经验，擅长：

- 使用 Chrome DevTools 进行DOM分析和样式提取
- 视觉识别图表类型、布局结构、交互模式
- 将设计稿/原型转化为结构化的开发规格
- ECharts/D3.js 等可视化库的配置推断

---

## 📋 T - 任务描述

使用 **chrome-devtools MCP** 和 **AI视觉分析** 的组合能力，从目标页面中自动提取指定组件的开发规格信息。

### 输入材料

#### 材料1：目标页面信息

```
【页面URL】{填写原型/设计稿的访问URL}

【目标组件】{填写要提取的组件名称或位置描述}
- 示例1: "右下角的中国地图组件"
- 示例2: "第二列第三个模块-资源统计柱状图"
- 示例3: "所有图表组件"

【组件类型】{地图/柱状图/折线图/饼图/仪表盘/表格/其他}
```

#### 材料2：提取范围

```
【提取内容】（勾选需要提取的信息）
☑ 基础信息：组件名称、位置、尺寸
☑ 视觉样式：颜色、边框、背景、阴影
☑ 数据结构：数据字段、类型、示例值
☑ 图表配置：图表类型、轴配置、图例
☑ 交互行为：hover效果、点击事件、动画
☑ 响应式：不同断点的表现
```

### 任务上下文

本任务是组件开发工作流的**前置步骤**，用于自动生成 P01-P12 各类提示词所需的输入材料，实现：

```
设计稿/原型 → [P00自动提取] → 结构化规格 → [P01-P12生成] → 组件代码
```

---

## 🎯 G - 目标与意图

### 核心目标

**自动化提取**设计稿/原型中组件的开发规格，**减少80%+的手工填写工作量**，确保提取信息的**准确性和完整性**。

### 具体目标

1. **精确提取**: 通过DOM分析获取精确的尺寸、位置、颜色值
2. **智能识别**: 通过视觉分析识别图表类型、数据模式、交互行为
3. **结构化输出**: 生成可直接用于P01-P12提示词的标准格式
4. **可复现**: 记录提取过程，便于后续验证和调整

### 业务价值

- **为开发者**: 减少重复性分析工作，专注于业务逻辑实现
- **为团队**: 统一组件规格格式，提高协作效率
- **为项目**: 缩短从设计到开发的周转时间

### 成功标准

- ✅ 尺寸、颜色等数值类信息100%准确（与DOM一致）
- ✅ 图表类型识别准确率≥95%
- ✅ 输出格式可直接复制到对应P0X提示词使用
- ✅ 提取过程≤5分钟/组件

---

## 📤 O - 输出要求

### 1. 提取流程（MCP工具调用序列）

```markdown
## Step 1: 打开目标页面
使用 `mcp_io_github_chr_new_page` 或 `mcp_io_github_chr_navigate_page`

## Step 2: 全页截图（视觉分析用）
使用 `mcp_io_github_chr_take_screenshot` 获取全页面截图

## Step 3: DOM快照（精确数据提取用）
使用 `mcp_io_github_chr_take_snapshot` 获取accessibility tree

## Step 4: 定位目标组件
从快照中找到目标组件的uid

## Step 5: 组件截图（可选，用于局部分析）
使用 `mcp_io_github_chr_take_screenshot` + uid 参数

## Step 6: 执行JavaScript提取精确数据
使用 `mcp_io_github_chr_evaluate_script` 提取：
- getBoundingClientRect() - 精确位置和尺寸
- getComputedStyle() - 实际渲染样式
- 图表实例配置（如 echarts.getInstanceByDom()）

## Step 7: 综合分析并生成结构化输出
结合视觉分析 + DOM数据，生成标准格式的组件规格
```

### 2. 输出格式模板

根据组件类型，输出对应的结构化信息：

---

#### 📊 地图组件提取结果模板

```markdown
# 组件提取结果：{组件名称}

## 基础信息
| 属性 | 值 | 来源 |
|------|-----|------|
| 组件名称 | {名称} | 视觉识别 |
| 位置坐标 | x:{x}px, y:{y}px | DOM提取 |
| 组件尺寸 | {width}px × {height}px | DOM提取 |
| 所在模块 | {父容器名称} | DOM提取 |

## 地图配置
| 属性 | 值 | 来源 |
|------|-----|------|
| 地图类型 | {中国地图/省级地图/世界地图} | 视觉识别 |
| 具体区域 | {全国/某省名} | 视觉识别 |
| 数据展示类型 | {区域着色/气泡标注/热力图} | 视觉识别 |

## 视觉样式
| 属性 | 值 | 来源 |
|------|-----|------|
| 区域填充色(低) | {#hex} | DOM提取/视觉识别 |
| 区域填充色(高) | {#hex} | DOM提取/视觉识别 |
| 边界线颜色 | {#hex} | DOM提取 |
| 边界线宽度 | {n}px | DOM提取 |
| 背景色 | {#hex} | DOM提取 |
| 标签颜色 | {#hex} | DOM提取 |

## 交互行为
| 行为 | 描述 | 来源 |
|------|------|------|
| Hover效果 | {区域高亮/显示Tooltip} | 视觉识别 |
| 点击行为 | {下钻/弹窗/无} | 视觉识别 |
| 缩放支持 | {是/否} | 视觉识别 |

## 数据结构推断
```typescript
interface MapDataItem {
  name: string      // 区域名称，如"广东省"
  value: number     // 数值，如 12580
  // 以下为可选字段（根据视觉分析推断）
  coord?: [number, number]  // 经纬度（气泡标注时需要）
}
```

## 可直接使用的P07输入
```
【组件名称】{组件名称}

【地图范围】
- 地图类型：{中国地图/省级地图/世界地图}
- 具体区域：{全国/某省}
- GeoJSON来源：{推荐来源}

【视觉效果】
- 尺寸：{width}px × {height}px
- 区域填充：渐变色，范围{低色}-{高色}
- 边界线：颜色{边界色}，宽度{边界宽度}px
- 背景色：{背景色}

【数据展示】
- 数据类型：{区域着色/气泡标注/热力图}
- 标签显示：{区域名称/数值/隐藏}

【交互效果】
- Hover：{区域高亮/显示Tooltip}
- 点击：{下钻/触发事件/无}
- 缩放：{支持/不支持}
```
```

---

#### 📈 图表组件提取结果模板（柱状图/折线图/饼图等）

```markdown
# 组件提取结果：{组件名称}

## 基础信息
| 属性 | 值 | 来源 |
|------|-----|------|
| 组件名称 | {名称} | 视觉识别 |
| 图表类型 | {bar/line/pie/radar/gauge} | 视觉识别 |
| 位置坐标 | x:{x}px, y:{y}px | DOM提取 |
| 组件尺寸 | {width}px × {height}px | DOM提取 |

## 图表配置
| 属性 | 值 | 来源 |
|------|-----|------|
| X轴类型 | {category/value/time} | 视觉识别 |
| X轴数据 | [{示例数据}] | 视觉识别 |
| Y轴类型 | {value/log} | 视觉识别 |
| Y轴范围 | {min}-{max} 或 auto | 视觉识别 |
| 系列数量 | {n}个 | 视觉识别 |
| 系列颜色 | [{#hex1}, {#hex2}, ...] | DOM提取/视觉识别 |

## 视觉样式
| 属性 | 值 | 来源 |
|------|-----|------|
| 柱宽/线宽 | {n}px | 视觉识别 |
| 圆角 | {n}px | 视觉识别 |
| 渐变方向 | {vertical/horizontal/none} | 视觉识别 |
| 网格线 | {显示/隐藏} | 视觉识别 |
| 图例位置 | {top/bottom/left/right} | 视觉识别 |

## 可直接使用的P0X输入
{根据图表类型生成对应提示词的输入格式}
```

---

### 3. JavaScript提取脚本模板

#### 通用组件信息提取

```javascript
// 在 mcp_io_github_chr_evaluate_script 中执行
(() => {
  const extractComponentInfo = (selector) => {
    const el = document.querySelector(selector);
    if (!el) return null;
    
    const rect = el.getBoundingClientRect();
    const style = getComputedStyle(el);
    
    return {
      // 位置和尺寸
      position: { x: Math.round(rect.x), y: Math.round(rect.y) },
      size: { width: Math.round(rect.width), height: Math.round(rect.height) },
      
      // 样式
      styles: {
        backgroundColor: style.backgroundColor,
        borderColor: style.borderColor,
        borderWidth: style.borderWidth,
        borderRadius: style.borderRadius,
        color: style.color,
        fontSize: style.fontSize,
        fontFamily: style.fontFamily
      }
    };
  };
  
  // 提取所有图表容器
  const chartContainers = document.querySelectorAll('[_echarts_instance_], .bindbindbindbindbindecharts-bindbindbindcontainer');
  const results = [];
  
  chartContainers.forEach((container, index) => {
    const info = extractComponentInfo(container);
    if (info) {
      // 尝试获取ECharts实例配置
      const instance = echarts.getInstanceByDom(container);
      if (instance) {
        info.echartsOption = instance.getOption();
      }
      results.push({ index, ...info });
    }
  });
  
  return results;
})();
```

#### 地图组件专用提取

```javascript
(() => {
  const mapContainers = document.querySelectorAll('[_bindbindbindbindbindbindecharts_bindinstance_bindBind]bindBind');
  const mapResults = [];
  
  mapContainers.forEach(bindcontainerBind =>bindBind {bindBind
    const instance = bindBindecharts.getInstanceByDom(container);
    if (!instance) return;
    
    const bindoptionbind = instance.bindgetbindOption();
    const bindhasbindMap = option.bindgeobind || option.bindseriesbind?.someBindbindBind(s => s.type ===bind 'bindmapbind');
    bind
    if (hasMap) {
      const bindgeobindConfig = option.geo?.[0] || {};
      const bindmapbindSeries = option.series?.find(sbind => s.type === 'map') || {};
      
      mapResults.push({
bindBind        bindcontainerbindId: container.idbind,
bind        bindmapbindName: geoConfig.map || bindmapbindSeries.map,
        bindbindBind bindvisualbindMap: option.visualMap,
bindBind        bindgeobind: {
          bindcenterbind: geoConfig.center,
          bindzoom: geoConfig.zoom,
          bindroam: geoConfig.roam,
          binditemStyle: geoConfig.itemStyle,
          bindemphasis: geoConfig.emphasis
        },bindBind
        bindbindBindsize: {
          width: container.bindoffsetWidth,
          height: container.offsetHeight
        }
      });
    }
  });
  
  return mapResults;
})();
```

---

### 4. 特别说明

#### 视觉识别与DOM提取的分工

| 信息类型 | 首选方法 | 备选方法 | 说明 |
|----------|----------|----------|------|
| 精确尺寸 | DOM提取 | - | getBoundingClientRect() |
| 精确颜色 | DOM提取 | 视觉识别 | getComputedStyle() |
| 图表类型 | 视觉识别 | ECharts实例 | 截图分析更可靠 |
| 数据模式 | 视觉识别 | ECharts实例 | 推断数据结构 |
| 交互行为 | 视觉识别 | - | 需要实际操作观察 |
| 动画效果 | 视觉识别 | - | 截图无法捕捉 |

#### 常见图表类型识别特征

| 图表类型 | 视觉特征 |
|----------|----------|
| 柱状图 | 垂直矩形条，等间距排列 |
| 折线图 | 连续线条，可能有数据点标记 |
| 饼图 | 圆形，扇形分割 |
| 地图 | 地理轮廓，区域着色 |
| 雷达图 | 多边形网格，放射状轴 |
| 仪表盘 | 半圆/圆弧，指针或进度条 |
| 散点图 | 离散点分布，无连线 |
| 热力图 | 网格/地图，颜色深浅表示强度 |

#### 信息不足时的处理

1. **颜色无法精确提取**: 使用视觉识别估算，标注"(估算值)"
2. **ECharts实例不可访问**: 完全依赖视觉识别
3. **交互行为无法确定**: 尝试hover/点击操作后观察
4. **数据结构不明确**: 提供最可能的结构，标注"(推断)"

---

## ✨ 使用示例

### 示例：提取南方电网大屏中的地图组件

```
【页面URL】http://localhost:8080/index.html?id=xxx&p=系统应用画像

【目标组件】用户运营分析模块中的地图

【组件类型】地图
```

**执行流程**:

1. `mcp_io_github_chr_navigate_page` → 打开页面
2. `mcp_io_github_chr_take_screenshot` → 全页截图用于视觉分析
3. `mcp_io_github_chr_take_snapshot` → 获取DOM结构
4. `mcp_io_github_chr_evaluate_script` → 执行JS提取精确数据
5. 综合分析 → 生成结构化的P07输入

**输出**: 自动填充好的 P07-地图组件生成提示词 输入材料

---

## 🔗 与其他提示词的关系

```
P00-组件信息自动提取 (本文件)
    │
    ├──→ P02-模块卡片 (提取卡片样式)
    ├──→ P03-折线图 (提取折线图配置)
    ├──→ P04-柱状图 (提取柱状图配置)
    ├──→ P05-饼图 (提取饼图配置)
    ├──→ P06-仪表盘 (提取仪表盘配置)
    ├──→ P07-地图 (提取地图配置)
    └──→ P08-表格 (提取表格配置)
```

**工作流优化**:
- **传统流程**: 人工分析设计稿 → 手动填写输入 → 运行提示词
- **优化流程**: 运行P00自动提取 → 直接获得填充好的输入 → 运行提示词
