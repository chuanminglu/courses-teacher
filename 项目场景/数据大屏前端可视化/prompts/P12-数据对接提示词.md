# P12-数据对接提示词（通用版）

> **📌 用途**: 为大屏组件对接后端数据接口，实现数据的获取、更新和实时推送。

---

## 🎭 R - 角色定义

你是一位资深全栈工程师，拥有8年前后端对接开发经验，擅长：

- RESTful API设计与对接
- WebSocket实时数据推送
- 前端数据层架构设计
- 异常处理与降级策略

---

## 📋 T - 任务描述

为大屏组件对接后端数据接口，实现数据的获取、更新和实时推送。

### 输入材料

#### 材料1：接口清单

```
【REST API】
- {HTTP方法} {接口路径}    # {接口描述}（{刷新频率}）
- 例如：
- GET /api/dashboard/overview      # 运营概览（5秒刷新）
- GET /api/dashboard/statistics    # 统计数据（10秒刷新）

【WebSocket】
- {WebSocket地址}    # {数据描述}
- 例如：
- ws://api/dashboard/alerts        # 实时告警推送
- ws://api/dashboard/metrics       # 实时指标推送

【数据格式】
{
  "code": {成功码，如0},
  "data": { ... },
  "message": "success",
  "timestamp": {时间戳}
}

【错误码】
- {错误码1}: {错误描述}
- {错误码2}: {错误描述}
```

#### 材料2：对接要求

```
【开发阶段】
- 使用Mock数据：{是/否}
- Mock数据模拟延迟：{延迟时间}ms
- 切换方式：{环境变量/配置文件}

【生产阶段】
- API Base URL：{配置方式}
- 请求超时：{超时时间}秒
- 重试策略：{重试次数}次，{重试间隔策略}
- 请求取消：{组件卸载时取消}

【实时数据】
- WebSocket重连：{重连次数}，间隔{重连间隔}
- 心跳检测：{心跳间隔}秒
- 消息队列：{是否缓存离线消息}

【鉴权方式】
- 认证方式：{Bearer Token/Cookie/无}
- Token刷新：{自动刷新/手动刷新}
```

#### 材料3：技术要求

```
- HTTP客户端：{Axios/Fetch/其他}
- WebSocket库：{原生/Socket.io/其他}
- 框架：{Vue 3/React 18}
- Mock方案：{MSW/Mock.js/Vite插件/其他}
```

### 任务上下文

这是大屏开发的最后阶段，将Mock数据替换为真实API，并实现WebSocket实时数据推送。

---

## 🎯 G - 目标与意图

### 核心目标

建立**稳定可靠**的数据对接层，确保大屏数据的实时性和准确性。

### 具体目标

1. **开发高效**: Mock数据支持离线开发，不依赖后端
2. **运行稳定**: 完善的错误处理和重试机制
3. **实时可靠**: WebSocket保持连接，数据实时更新
4. **可观测**: 请求日志、错误上报便于排查问题

### 业务价值

- **为开发团队**: 前后端解耦，并行开发
- **为运维人员**: 实时数据展示，及时响应
- **为系统稳定性**: 完善的容错机制

### 成功标准

- ✅ Mock模式下所有组件正常渲染
- ✅ 网络断开后自动重连恢复
- ✅ 单个接口失败不影响其他模块
- ✅ 数据更新延迟<500ms

---

## 📤 O - 输出要求

### 1. 输出结构

```
src/
├── api/
│   ├── client.ts              # HTTP客户端配置
│   ├── dashboard.ts           # 大屏API接口
│   └── types.ts               # API类型定义
├── mock/
│   ├── index.ts               # Mock服务入口
│   ├── handlers.ts            # MSW请求处理器
│   └── data/
│       └── dashboard.ts       # Mock数据
├── services/
│   ├── websocket.ts           # WebSocket管理
│   └── dataSync.ts            # 数据同步服务
└── composables/
    ├── useApi.ts              # API调用Hook
    └── useWebSocket.ts        # WebSocket Hook
```

### 2. 质量要求

#### 代码规范
- API函数返回类型明确
- 使用泛型定义响应类型
- 错误类型标准化

#### 性能规范
- 请求去重（相同请求合并）
- 缓存策略（stale-while-revalidate）
- 请求取消（AbortController）

#### 可靠性
- 网络错误自动重试
- WebSocket断线自动重连
- 降级策略（使用缓存数据）

### 3. 格式规范

- TypeScript严格模式
- 按功能模块组织

### 4. 特别说明

#### Axios实例配置

```typescript
// api/client.ts
import axios, { AxiosError, AxiosRequestConfig } from 'axios'

const client = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
client.interceptors.request.use((config) => {
  const token = getToken()
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

// 响应拦截器
client.interceptors.response.use(
  (response) => response.data,
  async (error: AxiosError) => {
    // 自动重试逻辑
    const config = error.config as AxiosRequestConfig & { _retryCount?: number }
    config._retryCount = config._retryCount || 0
    
    if (config._retryCount < 3 && isRetryableError(error)) {
      config._retryCount++
      await delay(1000 * config._retryCount) // 指数退避
      return client(config)
    }
    
    return Promise.reject(error)
  }
)

export { client }
```

#### WebSocket管理器

```typescript
// services/websocket.ts
export class WebSocketManager {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  private heartbeatInterval: number | null = null
  
  constructor(
    private url: string,
    private options: {
      onMessage: (data: any) => void
      onError?: (error: Event) => void
      heartbeatInterval?: number
    }
  ) {}
  
  connect() {
    this.ws = new WebSocket(this.url)
    
    this.ws.onopen = () => {
      this.reconnectAttempts = 0
      this.startHeartbeat()
    }
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      if (data.type !== 'pong') {
        this.options.onMessage(data)
      }
    }
    
    this.ws.onclose = () => {
      this.stopHeartbeat()
      this.tryReconnect()
    }
    
    this.ws.onerror = (error) => {
      this.options.onError?.(error)
    }
  }
  
  private tryReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000)
      setTimeout(() => this.connect(), delay)
    }
  }
  
  private startHeartbeat() {
    const interval = this.options.heartbeatInterval || 30000
    this.heartbeatInterval = window.setInterval(() => {
      this.ws?.send(JSON.stringify({ type: 'ping' }))
    }, interval)
  }
  
  private stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval)
    }
  }
  
  disconnect() {
    this.stopHeartbeat()
    this.ws?.close()
  }
}
```

#### Mock数据配置

```typescript
// mock/data/dashboard.ts
export const mockOverview = {
  code: 0,
  data: {
    systemName: '示例系统',
    status: 'normal',
    score: 98,
    metrics: {
      cpu: 45,
      memory: 62,
      disk: 78
    }
  },
  timestamp: Date.now()
}

// mock/handlers.ts (MSW)
import { rest } from 'msw'
import { mockOverview } from './data/dashboard'

export const handlers = [
  rest.get('/api/dashboard/overview', (req, res, ctx) => {
    return res(
      ctx.delay(200), // 模拟网络延迟
      ctx.json(mockOverview)
    )
  })
]
```

#### useApi Hook

```typescript
// composables/useApi.ts
export const useApi = <T>(
  fetcher: () => Promise<T>,
  options?: {
    immediate?: boolean
    refreshInterval?: number
    onSuccess?: (data: T) => void
    onError?: (error: Error) => void
  }
) => {
  const data = ref<T | null>(null)
  const loading = ref(false)
  const error = ref<Error | null>(null)
  
  const execute = async () => {
    loading.value = true
    error.value = null
    try {
      const result = await fetcher()
      data.value = result
      options?.onSuccess?.(result)
    } catch (e) {
      error.value = e as Error
      options?.onError?.(e as Error)
    } finally {
      loading.value = false
    }
  }
  
  // 立即执行
  if (options?.immediate) {
    execute()
  }
  
  // 定时刷新
  if (options?.refreshInterval) {
    const timer = setInterval(execute, options.refreshInterval)
    onUnmounted(() => clearInterval(timer))
  }
  
  return { data, loading, error, execute, refresh: execute }
}
```

---

## ✨ 输出格式

直接输出完整的代码文件，每个文件用代码块包裹，标注文件路径。
