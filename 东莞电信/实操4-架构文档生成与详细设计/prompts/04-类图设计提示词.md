# 04-类图设计提示词

## 💡 使用说明

本提示词用于根据逻辑视图设计，生成系统核心领域的类图（Class Diagram），展示类的属性、方法、关系。请将【】中的占位符替换为你的实际项目信息。

---

## 📋 完整提示词（复制以下内容到AI工具）

```
---

## 🎭 R - 角色定义

你是一位资深面向对象设计专家，拥有10年企业级系统建模经验，擅长：

- UML类图设计与面向对象建模
- 领域驱动设计（DDD）实体、值对象、聚合根建模
- 设计模式应用（GoF 23种模式）
- Mermaid类图语法与可视化
- SOLID原则与代码可维护性设计

---

## 📋 T - 任务描述

基于已完成的逻辑视图设计文档，为系统核心领域设计详细的类图，清晰展示类的属性、方法、关系（继承、实现、关联、依赖、聚合、组合）。

### 输入材料

#### 材料1：逻辑视图设计文档

【在此粘贴步骤03生成的逻辑视图设计文档完整内容】

#### 材料2：软件架构设计文档（SAD）（可选，用于补充上下文）

【在此粘贴步骤02生成的SAD文档，特别是§4逻辑架构设计和§6数据架构设计】

### 任务上下文

- 本任务是详细设计工作流的第四步，将逻辑视图中的组件和领域模型细化为类级别的设计
- 类图聚焦核心领域层（Domain Layer），包括聚合根、实体、值对象、领域服务
- 设计需遵循DDD战术建模和SOLID原则
- 所有设计决策需可追溯到逻辑视图文档

---

## 🎯 G - 目标与意图

### 核心目标

设计清晰、完整、符合OOP最佳实践的类图，确保开发团队能够直接基于类图进行编码实现。

### 具体目标

1. **领域模型具象化**: 将逻辑视图中的聚合根、实体、值对象转化为具体的类设计（属性+方法）
2. **关系明确性**: 清晰定义类之间的6种关系（继承、实现、关联、依赖、聚合、组合），避免歧义
3. **设计原则遵循**: 应用SOLID原则，确保类职责单一、开闭原则、依赖倒置
4. **可实现性**: 类图设计可直接映射到代码，属性类型、方法签名准确

### 业务价值

- **为开发团队**: 提供编码蓝图，减少设计理解偏差，提高开发效率
- **为代码评审**: 提供设计依据，识别违反OOP原则的实现
- **为单元测试**: 明确类的公共接口和行为，支撑测试用例设计
- **为重构**: 识别设计坏味道（如上帝类、循环依赖），指导重构方向

### 成功标准

- ✅ 为每个限界上下文提供完整的类图（使用Mermaid）
- ✅ 聚合根类包含完整的属性、方法、不变性约束逻辑
- ✅ 类之间的关系准确（继承/实现/关联/依赖/聚合/组合）
- ✅ 值对象设计符合不可变性原则
- ✅ 所有设计决策可追溯到逻辑视图文档

---

## 📤 O - 输出要求

### 1. 输出结构

#### 第1部分：类图设计总览

**1.1 设计范围**
- 说明本类图覆盖的限界上下文
- （来自逻辑视图§2.1 限界上下文划分）

**1.2 设计层次**
- 聚合根数量：【N个】
- 实体数量：【N个】
- 值对象数量：【N个】
- 领域服务数量：【N个】
- 仓储接口数量：【N个】

**1.3 类图图例说明**
- 使用表格说明Mermaid类图中的符号含义
- 格式：符号 | 关系类型 | 说明 | 示例场景

---

#### 第2部分：核心类图设计（按限界上下文组织）

针对每个限界上下文，提供以下内容：

**上下文：【上下文1名称】**

**2.1 上下文类图总览**
- 使用Mermaid classDiagram绘制该上下文的完整类图
- 包含所有聚合根、实体、值对象、领域服务、仓储接口
- 标注类之间的关系

```mermaid
classDiagram
    class 【聚合根1】{
        -【属性1类型】 【属性1名称】
        -【属性2类型】 【属性2名称】
        +【方法1】(参数): 返回值
        +【方法2】(参数): 返回值
    }
    
    class 【实体1】{
        -【属性】
        +【方法】
    }
    
    class 【值对象1】{
        -【属性】（不可变）
        +【方法】
    }
    
    【聚合根1】 "1" o-- "n" 【实体1】: 组合
    【实体1】 --> 【值对象1】: 依赖
```

**2.2 聚合根详细设计**

针对该上下文的每个聚合根，提供详细设计：

**聚合根：【聚合根1名称】**

- **职责**: 【业务职责描述】
- **不变性约束**: 【业务规则，如"订单总额必须等于订单项金额之和"】
- **生命周期**: 【创建→修改→完成/取消等状态流转】

**属性设计**：

| 属性名称 | 类型 | 可见性 | 必填 | 说明 | 业务规则 |
|---------|------|--------|------|------|----------|
| 【属性1】 | 【类型】 | private | 是 | 【说明】 | 【约束】 |
| 【属性2】 | 【类型】 | private | 否 | 【说明】 | 【约束】 |

**方法设计**：

| 方法名称 | 参数 | 返回值 | 可见性 | 职责 | 前置条件 | 后置条件 |
|---------|------|--------|--------|------|----------|----------|
| 【方法1】 | 【参数】 | 【返回值】 | public | 【职责】 | 【条件】 | 【断言】 |
| 【方法2】 | 【参数】 | 【返回值】 | public | 【职责】 | 【条件】 | 【断言】 |

**关联关系**：
- 组合：【关联的实体/值对象】（1对多/1对1）
- 依赖：【依赖的领域服务/仓储】

**设计模式应用**：
- 【如应用了某种模式，说明模式名称和应用场景】
- 示例：工厂模式（用于复杂聚合根创建）

---

**聚合根：【聚合根2名称】**
...（重复上述结构）

---

**2.3 实体详细设计**

**实体：【实体1名称】**

- **职责**: 【业务职责】
- **标识符**: 【ID类型和生成规则】
- **所属聚合**: 【所属的聚合根】

**属性设计**：（同上表格格式）

**方法设计**：（同上表格格式）

---

**2.4 值对象详细设计**

**值对象：【值对象1名称】**

- **职责**: 【业务概念】
- **不可变性**: 所有属性为final/readonly（来自DDD值对象原则）
- **相等性**: 基于值相等（重写equals/hashCode）

**属性设计**：（同上表格格式，强调不可变）

**方法设计**：
- 构造方法：【参数】，包含校验逻辑
- 业务方法：【如金额计算、格式化等】

**示例代码**（伪代码）：
```
class 【值对象名称】 {
    private final 【类型】 【属性1】;
    private final 【类型】 【属性2】;
    
    public 【值对象名称】(【参数】) {
        // 校验逻辑
        if (【校验条件】) throw new 【异常】;
        this.【属性1】 = 【值】;
    }
    
    public 【业务方法】() {
        // 业务逻辑
    }
}
```

---

**2.5 领域服务详细设计**

**领域服务：【领域服务1名称】**

- **职责**: 【跨聚合的业务逻辑】
- **无状态**: 不保存状态（来自DDD领域服务原则）

**方法设计**：（同上表格格式）

---

**2.6 仓储接口设计**

**仓储接口：【仓储1名称】**

- **职责**: 【聚合根持久化和查询】
- **聚合根**: 【对应的聚合根】

**接口方法**：
```
interface 【仓储接口名称】 {
    【聚合根】 findById(【ID类型】 id);
    void save(【聚合根】 aggregate);
    void delete(【ID类型】 id);
    List<【聚合根】> findBy【条件】(【参数】);
}
```

---

**上下文：【上下文2名称】**
...（重复上述第2部分结构）

---

#### 第3部分：跨上下文类图

**3.1 跨上下文集成接口**
- （来自逻辑视图§2.3 上下文集成策略）
- 使用Mermaid类图展示防腐层、适配器、开放主机服务的接口

**3.2 共享内核**
- 如有共享内核，展示共享的类/接口

---

#### 第4部分：类图设计总结

**4.1 设计统计**
- 使用表格汇总所有类的数量和复杂度
- 格式：上下文 | 聚合根数 | 实体数 | 值对象数 | 领域服务数 | 总类数

**4.2 设计亮点**
- 列出类图设计的3-5个核心亮点
- 示例：值对象不可变性、聚合边界清晰、SOLID原则应用

**4.3 设计约束**
- 说明类图设计的约束和限制
- 示例：聚合不跨数据库事务、值对象不单独持久化

**4.4 实现建议**
- 提供编码实现的关键建议
- 示例：使用Builder模式构建复杂聚合根、使用ORM映射聚合根

---

### 2. 质量要求

#### 可追溯性（强制）
- 所有类设计必须追溯到逻辑视图文档
- 引用格式：`（来自逻辑视图§2.2 聚合根设计）`

#### DDD战术建模（强制）
- 聚合根必须有唯一标识符（ID）
- 聚合根控制聚合边界内的实体（通过组合关系）
- 值对象必须不可变（所有属性final）
- 领域服务无状态，仅包含业务逻辑方法
- 仓储仅暴露聚合根操作（不直接操作实体）

#### SOLID原则（强制）
- **单一职责原则（SRP）**: 每个类职责单一
- **开闭原则（OCP）**: 通过继承/接口扩展，不修改现有类
- **里氏替换原则（LSP）**: 子类可替换父类
- **接口隔离原则（ISP）**: 接口细粒度，不强迫依赖不需要的方法
- **依赖倒置原则（DIP）**: 依赖抽象（接口），不依赖具体实现

#### 类图符号（强制）
- 使用Mermaid classDiagram语法
- 关系符号：
  - 继承：`<|--`
  - 实现：`<|..`
  - 关联：`-->`
  - 依赖：`..>`
  - 聚合：`o--`
  - 组合：`*--`
- 多重性：`"1" o-- "n"`（1对多组合）

#### 命名规范（强制）
- 类名：大驼峰（PascalCase）
- 方法名：小驼峰（camelCase）
- 属性名：小驼峰
- 常量：全大写下划线（UPPER_SNAKE_CASE）
- 接口名：以I开头或以able/ible结尾（根据团队规范）

---

### 3. 格式规范

- **文档格式**: Markdown
- **标题层级**: 使用##（第1部分）、###（2.1节）、####（聚合根详细设计）
- **表格**: 用于属性设计、方法设计、设计统计
- **代码块**: 接口定义、值对象示例使用伪代码
- **Mermaid图表**: 使用\`\`\`mermaid classDiagram代码块
- **Emoji**: 
  - 🎯 聚合根
  - 📦 实体
  - 💎 值对象
  - 🔧 领域服务
  - 💾 仓储
  - 🔗 关联关系

---

### 4. 特别说明

#### 聚合边界设计原则
- 聚合是一致性边界（事务边界）
- 一个聚合一个事务（不跨聚合事务）
- 聚合间通过ID引用，不直接持有对象引用
- 聚合尽量小（避免上帝聚合）

#### 值对象设计要点
- 值对象不可变（所有属性final，无setter）
- 值对象相等性基于值（重写equals/hashCode）
- 值对象包含校验逻辑（构造时验证）
- 值对象可以有业务方法（如Money.add()）

#### 领域服务 vs 应用服务
- **领域服务**: 跨聚合的核心业务逻辑，属于领域层
- **应用服务**: 编排业务流程，事务管理，属于应用层
- 本类图仅设计领域服务，不包含应用服务

#### 仓储设计原则
- 仓储是接口，定义在领域层
- 仓储实现在基础设施层（本类图不展示实现）
- 仅为聚合根提供仓储（不为实体或值对象提供）
- 仓储方法语义清晰（findById、save、delete）

#### 信息不足的处理
如果逻辑视图中缺少某些设计细节，你应该：
1. **基于DDD战术建模补充**: 标注`（基于DDD战术建模补充）`
2. **参考行业通用设计**: 标注`（参考{模式/实践}）`
3. **标注待确认项**: `【待确认】{设计决策}`

---

### 5. 输出格式

直接输出完整的类图设计文档，不要有任何前言或解释。文档以"# 类图设计文档（Class Diagram）"开头。

---
```

---

## 📌 示例：访客管理系统的输入材料

假设你要为"访客管理系统"设计类图，输入材料应该是：

### 输入材料示例

```
#### 材料1：逻辑视图设计文档

（这里粘贴步骤03生成的完整逻辑视图文档，特别关注：
- §2 领域模型设计（DDD）
  - §2.1 限界上下文划分
  - §2.2 各限界上下文详细设计（聚合根、领域服务、领域事件）
）

#### 材料2：软件架构设计文档（SAD）（可选）

（这里粘贴步骤02生成的SAD文档§4和§6，用于补充技术约束）
```

生成的类图会包含详细的类设计，如：

```
**聚合根：Visitor（访客）**

- **职责**: 管理访客信息、访问申请、访问记录
- **不变性约束**: 
  - 访客手机号必须唯一且已验证
  - 访问时间必须在预约时间范围内
  - 访客状态流转必须符合：待审批→已批准→已签入→已签出

**属性设计**：

| 属性名称 | 类型 | 可见性 | 必填 | 说明 | 业务规则 |
|---------|------|--------|------|------|----------|
| id | VisitorId | private | 是 | 访客唯一标识 | UUID生成 |
| name | String | private | 是 | 访客姓名 | 2-50字符 |
| phone | PhoneNumber | private | 是 | 手机号（值对象） | 已验证 |
| company | String | private | 否 | 所属公司 | 最多100字符 |
| status | VisitorStatus | private | 是 | 访客状态（枚举） | 见状态机 |
| visits | List<Visit> | private | 是 | 访问记录（实体） | 组合关系 |

**方法设计**：

| 方法名称 | 参数 | 返回值 | 可见性 | 职责 | 前置条件 | 后置条件 |
|---------|------|--------|--------|------|----------|----------|
| applyVisit | (VisitRequest) | Visit | public | 申请访问 | status=待审批 | 创建Visit并设为待审批 |
| approveVisit | (VisitId) | void | public | 批准访问 | Visit存在且为待审批 | Visit状态=已批准 |
| checkIn | (VisitId) | void | public | 签入 | Visit已批准且在预约时间内 | Visit状态=已签入 |
| checkOut | (VisitId) | void | public | 签出 | Visit已签入 | Visit状态=已签出 |

...
```
